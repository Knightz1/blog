---
layout: post
title: "PLAY ransomware"
categories: malware analysis
toc: true
---

## 1. SAMPLE: 

[Play ransomware](https://bazaar.abuse.ch/sample/006ae41910887f0811a3ba2868ef9576bbd265216554850112319af878f06e55/)

## 2. Static analysis

- Hàm main:

![image](https://user-images.githubusercontent.com/91442807/204834393-586fe8fb-17e7-4990-96db-8595406e63d8.png)

- Có vẻ IDA dịch không rõ lắm, xem lại asm:

![image](https://user-images.githubusercontent.com/91442807/204834819-179eb4a1-1dbc-45f8-80bb-e124cc2819aa.png)

![image](https://user-images.githubusercontent.com/91442807/204834894-0317a55b-496a-48e1-9d96-09d37e94f644.png)

- Có vẻ hàm lấy giá trị trên cùng của stack + 0x35 

- Note:

```
Khi chương trình gọi lệnh call một hàm thì giá trị trên cùng của stack sẽ lưu địa chỉ của instruction tiếp theo.
```

-> Có nghĩa lấy địa chỉ của `pop edi` là `0xD042F1` + `0x35`.

- Debug thử:

![image](https://user-images.githubusercontent.com/91442807/204836716-2f3b24b7-b81e-4227-a549-a479ce185eee.png)

![image](https://user-images.githubusercontent.com/91442807/204836858-2264ba06-0bc5-44e5-89b4-f1e99e0414d1.png)

-> Đúng là như vậy.

- Sau khi tính toán được giá trị mới thì chương trình nhảy đến địa chỉ đó luôn:

![image](https://user-images.githubusercontent.com/91442807/204837190-c7ab0a42-4101-4402-9c90-1a25788ca689.png)

-> Tới đây ta có thể patch lại bằng cách tự tính toán địa chỉ và thay thể lệnh `call` bằng `jump`.

![image](https://user-images.githubusercontent.com/91442807/204837969-7d35574a-5d7b-4458-b3f6-2a6313933aa4.png)

- Có thể dùng tool [keypatch](https://github.com/keystone-engine/keypatch#appendix-install-keystone-for-ida-pro) để patch lại cho dễ.

- Kéo tiếp xuống dưới lại gặp hàm tương tự nên ta cũng thực hiện tương tự cuối cùng có thể có thể decompile được hàm main:

![image](https://user-images.githubusercontent.com/91442807/204838795-463b5ca1-c6f2-4b31-964f-7b032c8c6391.png)



## 3. Patch anti-analysis

- Đi sâu vào hàm main ta bắt gặp kĩ thuật tương tự và rất nhiều nên không thể patch lại bằng tay toàn bộ được.

- Để ý các các chỗ obfuscate đó đều có dạng như sau:

![image](https://user-images.githubusercontent.com/91442807/204843265-8bf84809-23d6-4c86-bf64-81675ef03577.png)

![image](https://user-images.githubusercontent.com/91442807/204843915-5a2f9523-f5e9-4bd9-a751-46c217afe614.png)

-> Có thể dựa vào để tìm và patch lại các chỗ bị obfuscate

### Script patch:

```python
import re
from pwn import *
data= open("PLAY_ransom.exe", "rb").read()

regex = b'\x06\x81\xC4....\x83\xC4.\xE8....'
count=0

for match in re.finditer(regex, data):
    count += 1
    next_ins_addr = match.start()+15    # ins addr after call ins
    bytes_matched= match.group()
    func_called_addr=u32(bytes_matched[bytes_matched.find(b'\xe8')+1:])+next_ins_addr
    
    add_val=data[func_called_addr+3]

    #jmp_addr=next_ins_addr+add_val
    patch_addr=next_ins_addr-5

    #patch
    data1=list(data)
    data1[patch_addr:patch_addr+5]=list(b'\xe9'+p8(add_val)+b'\x00'*3) #change call =jmp
    data=bytes(data1)

pat=open("patched.exe", "wb")
pat.write(data)
print("[+]Done")
```

## 4. API hashing

- Quan sát `sub_40C750`:

![image](https://user-images.githubusercontent.com/91442807/204848621-7cf5ecc6-ebe2-40e8-ac18-371d88835390.png)

- Ta thấy có rất nhiều hàm như vậy và mỗi hàm đều có hằng số đưa vào, dựa trên kinh nghiệm mấy bài trước khá chắc đây là kĩ thuật `API hashing`

- Xem hàm thử: 

![image](https://user-images.githubusercontent.com/91442807/204850072-86fb674b-ee54-46bb-9f6b-7d21fe28917d.png)

- Chương trình lấy `API_name` rồi tính hash rồi so sánh với giá trị ban đầu đưa vào.

- Hàm `calculate_hash` sử dụng bằng phép tính toán gì đó rất dài nên không thể nào viết lại bằng python rồi tính hash được.

-> Debug cũng không được vì chỉ có thể debug được đối với binary `ban đầu` còn binary `sau khi patch` không biết sao lại lỗi:

![image](https://user-images.githubusercontent.com/91442807/204852135-699f8deb-4353-4d56-a967-295799633998.png)

-> Nhưng khi debug đối với cái ban đầu thì không đơn giản là đặp bp tại đó rồi debug vì khi đó chương trình sẽ nhảy vào code rác của obfuscate và gây crash chương trình -> bắt buộc phải đặt bp tại `main` rồi `step` từ từ cho chương trình tự deobfuscate tới khi nào đến chỗ cần xem -> rất mất thời gian.

### Emulate calculate_hash dùng unicorn

-> Chỉ cần emulate code của hàm `calculate_hash` rồi đưa vào các tham số phù hợp là được.

- Bước 1: extract code của hàm `calculate_hash`:

```python
import idaapi, idc
SHA1HashAddr = idc.get_name_ea_simple("calculate_hash")
SHA1Hash = idaapi.get_func(SHA1HashAddr)
SHA1HASH_OPCODE = idaapi.get_bytes(SHA1Hash.start_ea, SHA1Hash.size())
print(SHA1HASH_OPCODE)
```
```b"U\x8b\xec\x83\xec V\x8b\xc2\x89M\xfc3\xf6\x89E\xe0W\x8b\xf8\x85\xc9u\x1b\x8bM\x08\x81\xc1\xb1gV\x16\x8b\xc1\xc1\xe8\x0f3\xc1i\xc8w\xca\xeb\x85\xe9\x07\x02\x00\x00S\x83\xf8\x10\x0f\x82j\x01\x00\x00\x8b]\x08\x8d\x93(D#$\x89U\xe8\x8d\x83O\x86\xc8a\x8d\x93w\xca\xeb\x85\x89U\xec\x8dQ\x03\x89U\xf8\x8dQ\x02A\x89U\xf4\x8bU\xf8\x89M\xf0\x8b\xcf\xc1\xe9\x04\x89M\xe4\x0f\xb6\x142\x83\xef\x10\x8bM\xf4\xc1\xe2\x08\x0f\xb6\x0c1\x0b\xd1\x8bM\xf0\xc1\xe2\x08\x0f\xb6\x0c1\x0b\xd1\x8bM\xfc\xc1\xe2\x08\x0f\xb6\x0c\x0e\x0b\xd1i\xca\x895\x14z\x8bU\xe8+\xd1\x8bM\xf8\xc1\xc2\ri\xd2\xb1y7\x9e\x89U\xe8\x0f\xb6T1\x04\x8bM\xf4\xc1\xe2\x08\x0f\xb6L1\x04\x0b\xd1\x8bM\xf0\xc1\xe2\x08\x0f\xb6L1\x04\x0b\xd1\x8bM\xfc\xc1\xe2\x08\x0f\xb6L\x0e\x04\x0b\xd1i\xca\x895\x14z\x8bU\xec+\xd1\x8bM\xf8\xc1\xc2\ri\xd2\xb1y7\x9e\x89U\xec\x0f\xb6T1\x08\x8bM\xf4\xc1\xe2\x08\x0f\xb6L1\x08\x0b\xd1\x8bM\xf0\xc1\xe2\x08\x0f\xb6L1\x08\x0b\xd1\x8bM\xfc\xc1\xe2\x08\x0f\xb6L\x0e\x08\x0b\xd1i\xca\x895\x14z+\xd9\x8bM\xf8\xc1\xc3\ri\xdb\xb1y7\x9e\x0f\xb6T1\x0c\x8bM\xf4\xc1\xe2\x08\x0f\xb6L1\x0c\x0b\xd1\x8bM\xf0\xc1\xe2\x08\x0f\xb6L1\x0c\x0b\xd1\x8bM\xfc\xc1\xe2\x08\x0f\xb6L\x0e\x0c\x83\xc6\x10\x0b\xd1i\xca\x895\x14z\x8bU\xf8+\xc1\xc1\xc0\ri\xc0\xb1y7\x9e\x83m\xe4\x01\x0f\x85\xe8\xfe\xff\xff\x8bU\xec\x8bM\xfc\xc1\xc8\x0e\xc1\xc3\x0c\xc1\xc2\x07\x03\xc3\x03\xc2\x8bU\xe8\xd1\xc2\x03\xc2\xeb\x08\x8bE\x08\x05\xb1gV\x16\x03E\xe0\x83\xff\x04rP\x8b\xdf\xc1\xeb\x02\xeb\x05f\x90\x8bM\xfc\x0f\xb6T1\x03\x83\xef\x04\x0f\xb6L1\x02\xc1\xe2\x08\x0b\xd1\x8bM\xfc\xc1\xe2\x08\x0f\xb6L1\x01\x0b\xd1\x8bM\xfc\xc1\xe2\x08\x0f\xb6\x0c1\x83\xc6\x04\x0b\xd1i\xca\xc3QM=+\xc1\xc1\xc8\x0fi\xc0/\xeb\xd4'\x83\xeb\x01u\xb9[\x85\xfft!\x8bU\xfc\x03\xd6\x0f\xb6\n\x8dR\x01i\xc9\xb1gV\x16\x03\xc8\xc1\xc1\x0bi\xc1\xb1y7\x9e\x83\xef\x01u\xe4\x8b\xc8\xc1\xe9\x0f3\xc8i\xc9w\xca\xeb\x85\x8b\xc1\xc1\xe8\r3\xc1i\xc8=\xae\xb2\xc2_^\x8b\xc1\xc1\xe8\x103\xc1\x8b\xe5]\xc3"```










